/*
Пример 1 (C++):
В лесу живет слон весом в 7 тонн. И 100 000 000 комаров весом 1/1000 грамма +-10%.
Сколько кг живых существ обитает в лесу.
*/
int main(){
	float weight;
	float elephant = 7000;
	weight = elephant; // = 0;
	for (int i = 0; i < 100 000 000; i++)
	{
		float moscito = (0.1 * rand() / RANDMAX + 0.9) * 1E-6;
		weight += moscito;
	}
	// weight += elephant; // так будет работать
	cout << weight; //Программа выводит только вес слона
	return 0;
}
/*
Нужно избегать присваивания маленького к большому.
Пример 2:
*/
 for i:= 1 to 10 do
 	if sin(i)*sin(i)+cos(i)*cos(i) = 1 then
 		writeln ("Тождество верно");
 	else 
 		writeln ("Тождество неверно");
 /*
 Поэтому сравнение вещественных следует вести с учетом заданной точности
 */
abs(sin(i)*sin(i)+cos(i)*cos(i) - 1) < eps //правильное условие
/*
real     - 6  байт
single   - 4  байт
double   - 8  байт
extended - 10 байт

						2.6 Интервальный тип
Определяется как значение интревала ранее определенного скалярного типа.
Интервал определяется указанием минимального и максимального значения.
*/
Type = tmin..tmax;
Digits = 0..9;
/*
Операции определенные для ... типа определены и для интервального типа. 
В пределах указанного диапазона

						3 Структурированные типы данных
						3.1 Функция с конечной областью определения
Представляет собой отображение некоторого конечного множества данных на множество данных 
другого типа. В традиционных языках программирования такой тип называют массивом. Область
определения это множество индексов, а множество значений - элементы массива.
*/
Type T = array[i] of T0;
/*
T0 - тип элементов массива и тип индексов. И любой скалярный тип.
*/
T = array [1..3] of char;
/*
card(T) = card(T0)^card(i)
Пример 1:
Небходимо создать тип данных для хранения шахматных позиций
*/
Type Figura = (wKing, bKing, wQueen, bQueen, wBishop, bBishop, 
				wkNight, bkNight, wRook, bRook, wpawn, bpawn, none);
Type ChessBoard = array['a'..'h', 1..8] of Figura;

var c:ChessBoard;
c['e', 1] := wKing;
/*
Пример 2:
Поиск элемента массива (Поиск с барьерным элементом)
*/
var a: array[1..n + 1] of integer;
	x: integer;
	i:=0;
	a[n+1]:=x;
	repeat
		i:=i+1;
	until (a[i]=x);
	if (i = n+1) then
		writeln("Есть");
	else
		writeln("Нет");
/*
Пример 3:
Требует предварительной сортировки массива. Осуществляется повторное 
деление пополам интервала в  котором ищем элемент значения x. Алгоритм называется -
метод половинного деления (метод бисекции);
*/
var a: array[1..n] of integer;
i:=1;
j:=N;
repeat
	k:=(i+j) div 2;
	if x>a[k] then
		i:=k+1;
	else
		j:=k-1;
until (a[k] = x)
if a[k] <> x then
	//...
/*
						3.2 ---
В отличии от массива компоненты записи могут принадлежать к ранее определенным типам.
С точки зрения матеши такой составной тип является прямым или декартовым произведениям типов компонент.
*/
Type 
	T = record 
			S1:T1;
			S2:T2;
			...
			SN:TN;
	end;
card(T) = card(T1)*card(T2)*...*card(TN);

Type 
	Date:record
			day:1..31;
			month:1..12;
			year:word;
	end;
/*
Пример: Известны следующие сведения о группе американцев: ФИ, дата рождения, пол, семейное положение.
Необходимо обеспечить хранение данной информации, а затем подсчитать кол-во одиноких женщин.
*/
Type 
	Person:record
		name:string[23];
		surname:string[31];
		bDay:Date;
		sex:(male, female);
		marstatus:(single, married, widowed,divorced);
	end;
var 
	p:array[1..n] of Person;
	...
/*
						3.3 Записи с вариантами
В практической работе часто бывает удобным и естественным рассматривать 2 различных типа 
как варианты 1 и того же типа. Например тип 
*/
Type 
	Coordinate 
/*
Можно рассматривать как объединение декартовых и полярных координат. Чтобы определить какой вариант
принят в данный момент вводят доп. компоненту, которую называют дискриминантом типа или полем признака.
*/
Type 
	Coordinate:record
		kind:(decart, polar) of 
		decart:(x, y:real);
		polar:(r, fi:real);
	end;
/*
card() вариантной записи = сумме card() ...
Обычно приходится объединять не 2 полностью различных типа, а 2 типа с частично совпадающими компонентами
примерном может служить типа Рerson, если необходимо хранить существенные признаки в зависимости от пола.
Для мужчин считаем существенными вес и наличие бороды, а для женщин 3 основных размера.
*/
Type 
	Person:record
		name, surname:string;
		bDay:Date;
		marStatus:(single, married, widowed,divorced);
		case sex: (male, female) of
			male:(weight:real, bearded:boolean);
			female: (size:array[1..3] of byte);
	end;
/*
						3.4 Множества
Множества представляют собой тип данных, значением которого является множество элементов
кокого-либо базового типа. Множества бывают 2 типов: 1)Множество, хранящее элеметы
													 2)Множество, хранящее информацию о наличии или отсутствии элементов
*/
Type
	T = set of 1..30;
var
	s:T;
s:=[1, 5..8, 17];
boolean b := 6 in s;
/*
						4 Последовательности
Отличие последовательностей от рассматриваемых ранее структурированных типов данных
состоит в том, что card() последовательностей конечно, но не фиксированно.

Операции над последовательностями
1)Формирование последовательности
Последовательность T, состоящая из элементов от e1 до en представляют в следующем виде
*/
T(e1, e2, ... , en)
/*
при n = 0
*/
T()
/*
2)Выборка или чтение элементов 
*/
x = T(e1, e2, ... , en)
x[i] //Произвольный элемент
first(x) //Начальный элемент
last(x) //Конечный элемент
tail(x) //Удаляет начальный элемент
initail(x) //Удаляет последний элемент
appendl(x, e) //Добавляет в начало
appendr(x, e) //Добавляет в конец
/*
В зависимости от типа разрешенных операций существуют различные виды последовательности
						4.1 Последовательный файл
Это последовательность, над которой разрены следующие операции
a)T()
b)first(x)
c)tail(x)
d)appendr(x, e)
e)empty(x)

Обработка файла ведется путем использованияфайловой переменной, которая является адресом очередной 
считывающей\записываемой компоненты и буферной переменной имеющей тип одинаковый с компонентам файлов.  
*/
var
	f:text;
	buf:string;
assign(f, 'name');
reset(f); //открытие для чтения
rewrite(f); //Открытие для записи нового файла
append(f); //Открытие для дозаписи
readln(f, buf); //Чтение файла
writeln(f, buf); //Запись файла
eof(f); // end of file
close(f);
/*
						4.2 Файл с прямым доступом
Для файла с прямым доступом разрешены все операции, что и для файла с последовательным доступом
(
a)T()
b)first(x)
c)tail(x)
d)appendr(x, e)
e)empty(x)
) + операция x[i] - доступ к произвольному элементу.
Данынй тип файлов появился с возникновением устройств накопительно магнитный диск.
При доступе к произвольному элементу вычисляется номер кластера, где находится данный элемент,
а затем этот кластер целиком, последовательно, считывается в оперативную память. 
Таким образом прямой доступ не отменяет последовательный, а лишь значительно сокращает его объем. 
*/
var
	f:file of T;
	buf:to;
reset(f); //позвоняет как читать так и писать
seek(f, pos); //поиск позиции 
/*
						4.3 Стек
Разрешены следующие операции
а)T()
b)first(x) // top - смотрит
c)tail(x) // pop - извлекает
d)appendl(x, e) // push - кладет
e)empty(x) //проверка
Реализация стека в программах
1)На основе вектора (одномерного массива)
Операции pop и push не должны приводить к массовым оперциям,
их быстродействие не должно зависить от количества элементов в стеке
2)Линейный односвязный список

Пример 1: Проверка правильности расстановки скобок.
Дано выражение с 3 видами скобок ({[, необходимо проверить правильность расстановки.
Алгоритм: Выражение просматривается слева направо, если встречается открывающаяся скобка,
она заносится в стек, если встречается закрывающаяся, то из стека извлекается открывающаяся и проверяется парность.
После окончания просмотра должен остаться пустой стек.
Пример 2: Вычисление выражений.
Наиболее широко используется инфексная форма записи Операнд->a Операция->+ Операнд->b (a + b)
Так же бывает префиксная +ab и постфиксная ab+.
Вычисление выражений, записанных в постфиксной форме, сводится к несложному алгоритму и, кроме того, не требуются скобки

Алгоритм вычисления выражения, записанного в постфиксной форме
*/

/*

*/

/*

*/

/*

*/

/*

*/

/*

*/

/*

*/

/*

*/

/*

*/