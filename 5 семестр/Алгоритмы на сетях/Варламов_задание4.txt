-Что является входом для алгоритма Форда-Беллмана, что – результатом работы? 
Орграф G = <V, E> с n вершинами и выделенным источником s, заданный списками инцидентности, матрица весов A[u, v], u,v  V; граф не содержит контуров отрицательной длины.

-Какова его вычислительная сложность?
Вычислительная сложность алгоритма О(nm). Если граф является «разреженным» и число дуг m~n , то можно считать вычислительную сложность равной О(n^2), иначе О(n^3).

private static final int INF = 9999;

private void bellmanFord(int graph[][], int src) {
    int V = graph.length;
    int[] dis = new int[V];
    ArrayList<Integer> tmp = new ArrayList<>();

    for (int i = 0; i < V; i++)
        dis[i] = INF;

    dis[src] = 0;

    for (int k = 0; k < V - 1; k++) {
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                tmp.add(dis[j] + graph[j][i]);
            }
            dis[i] = tmp.stream().min(Integer::compare).get();
            tmp.clear();
        }
    }

    System.out.println("Vertex Distance from " + src);
    for (int i = 0; i < V; i++)
        System.out.println("to " + i + "\t\t" + dis[i]);
}

public void find() {
        int graph[][] = {
                {0, -1, 4, INF, INF},
                {INF, 0, 3, 2, 2},
                {INF, INF, 0, INF, INF},
                {INF, 1, 5, 0, INF},
                {INF, INF, INF, -3, 0}
        };
    bellmanFord(graph, 0);
}